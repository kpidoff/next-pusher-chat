"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/flairup@1.0.0";
exports.ids = ["vendor-chunks/flairup@1.0.0"];
exports.modules = {

/***/ "(api)/../../node_modules/.pnpm/flairup@1.0.0/node_modules/flairup/dist/index.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/.pnpm/flairup@1.0.0/node_modules/flairup/dist/index.js ***!
  \*********************************************************************************/
/***/ ((module) => {

eval("\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = function(target, all) {\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = function(to, from, except, desc) {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            var _loop = function() {\n                var key = _step.value;\n                if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n                    get: function() {\n                        return from[key];\n                    },\n                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n                });\n            };\n            for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    return to;\n};\nvar __toCommonJS = function(mod) {\n    return __copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n};\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    createSheet: function() {\n        return createSheet;\n    },\n    cx: function() {\n        return cx;\n    }\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/utils/asArray.ts\nfunction asArray(v) {\n    return [].concat(v);\n}\n// src/utils/is.ts\nfunction isPsuedoSelector(selector) {\n    return selector.startsWith(\":\");\n}\nfunction isStyleCondition(selector) {\n    return isString(selector) && (selector === \"*\" || selector.length > 1 && \":>~.+*\".includes(selector.slice(0, 1)) || isImmediatePostcondition(selector));\n}\nfunction isValidProperty(property, value) {\n    return (isString(value) || typeof value === \"number\") && !isCssVariables(property) && !isPsuedoSelector(property) && !isMediaQuery(property);\n}\nfunction isMediaQuery(selector) {\n    return selector.startsWith(\"@media\");\n}\nfunction isDirectClass(selector) {\n    return selector === \".\";\n}\nfunction isCssVariables(selector) {\n    return selector === \"--\";\n}\nfunction isString(value) {\n    return value + \"\" === value;\n}\nfunction isImmediatePostcondition(value) {\n    return isString(value) && (value.startsWith(\"&\") || isPsuedoSelector(value));\n}\n// src/utils/joinTruthy.ts\nfunction joinTruthy(arr) {\n    var delimiter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    return arr.filter(Boolean).join(delimiter);\n}\n// src/utils/stableHash.ts\nfunction stableHash(prefix, seed) {\n    var hash = 0;\n    if (seed.length === 0) return hash.toString();\n    for(var i = 0; i < seed.length; i++){\n        var char = seed.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash;\n    }\n    return \"\".concat(prefix !== null && prefix !== void 0 ? prefix : \"cl\", \"_\").concat(hash.toString(36));\n}\n// src/utils/stringManipulators.ts\nfunction handlePropertyValue(property, value) {\n    if (property === \"content\") {\n        return '\"'.concat(value, '\"');\n    }\n    return value;\n}\nfunction camelCaseToDash(str) {\n    return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction joinedProperty(property, value) {\n    return \"\".concat(property, \":\").concat(value);\n}\nfunction toClass(str) {\n    return str ? \".\".concat(str) : \"\";\n}\nfunction appendString(base, line) {\n    return base ? \"\".concat(base, \"\\n\").concat(line) : line;\n}\n// src/Rule.ts\nvar Rule = /*#__PURE__*/ function() {\n    function _Rule(sheet, property, value, selector) {\n        _class_call_check(this, _Rule);\n        this.sheet = sheet;\n        this.property = property;\n        this.value = value;\n        this.selector = selector;\n        this.property = property;\n        this.value = value;\n        this.joined = joinedProperty(property, value);\n        var joinedConditions = this.selector.preconditions.concat(this.selector.postconditions);\n        this.hash = this.selector.hasConditions ? this.selector.scopeClassName : stableHash(this.sheet.name, this.joined);\n        this.key = joinTruthy([\n            this.joined,\n            joinedConditions,\n            this.hash\n        ]);\n    }\n    _create_class(_Rule, [\n        {\n            key: \"toString\",\n            value: function toString() {\n                var selectors = mergeSelectors(this.selector.preconditions, {\n                    right: this.hash\n                });\n                selectors = mergeSelectors(this.selector.postconditions, {\n                    left: selectors\n                });\n                return \"\".concat(selectors, \" {\").concat(_Rule.genRule(this.property, this.value), \"}\");\n            }\n        }\n    ], [\n        {\n            key: \"genRule\",\n            value: function genRule(property, value) {\n                var transformedProperty = camelCaseToDash(property);\n                return joinedProperty(transformedProperty, handlePropertyValue(property, value)) + \";\";\n            }\n        }\n    ]);\n    return _Rule;\n}();\nfunction mergeSelectors(selectors) {\n    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref_left = _ref.left, left = _ref_left === void 0 ? \"\" : _ref_left, _ref_right = _ref.right, right = _ref_right === void 0 ? \"\" : _ref_right;\n    var output = selectors.reduce(function(selectors2, current) {\n        if (isPsuedoSelector(current)) {\n            return selectors2 + current;\n        }\n        if (isImmediatePostcondition(current)) {\n            return selectors2 + current.slice(1);\n        }\n        return joinTruthy([\n            selectors2,\n            current\n        ], \" \");\n    }, left);\n    return joinTruthy([\n        output,\n        toClass(right)\n    ], \" \");\n}\nvar Selector = /*#__PURE__*/ function() {\n    function _Selector(sheet) {\n        var scopeName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, preconditions = _ref.preconditions, postconditions = _ref.postconditions;\n        _class_call_check(this, _Selector);\n        this.sheet = sheet;\n        this.preconditions = [];\n        this.scopeClassName = null;\n        this.scopeName = null;\n        this.postconditions = [];\n        this.preconditions = preconditions ? asArray(preconditions) : [];\n        this.postconditions = postconditions ? asArray(postconditions) : [];\n        this.setScope(scopeName);\n    }\n    _create_class(_Selector, [\n        {\n            key: \"setScope\",\n            value: function setScope(scopeName) {\n                if (!scopeName) {\n                    return this;\n                }\n                if (!this.scopeClassName) {\n                    this.scopeName = scopeName;\n                    this.scopeClassName = stableHash(this.sheet.name, // adding the count guarantees uniqueness across style.create calls\n                    scopeName + this.sheet.count);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"hasConditions\",\n            get: function get() {\n                return this.preconditions.length > 0 || this.postconditions.length > 0;\n            }\n        },\n        {\n            key: \"addScope\",\n            value: function addScope(scopeName) {\n                return new _Selector(this.sheet, scopeName, {\n                    preconditions: this.preconditions,\n                    postconditions: this.postconditions\n                });\n            }\n        },\n        {\n            key: \"addPrecondition\",\n            value: function addPrecondition(precondition) {\n                return new _Selector(this.sheet, this.scopeClassName, {\n                    postconditions: this.postconditions,\n                    preconditions: this.preconditions.concat(precondition)\n                });\n            }\n        },\n        {\n            key: \"addPostcondition\",\n            value: function addPostcondition(postcondition) {\n                return new _Selector(this.sheet, this.scopeClassName, {\n                    preconditions: this.preconditions,\n                    postconditions: this.postconditions.concat(postcondition)\n                });\n            }\n        },\n        {\n            key: \"createRule\",\n            value: function createRule(property, value) {\n                return new Rule(this.sheet, property, value, this);\n            }\n        }\n    ]);\n    return _Selector;\n}();\n// src/Sheet.ts\nvar Sheet = /*#__PURE__*/ function() {\n    function Sheet(name, rootNode) {\n        _class_call_check(this, Sheet);\n        this.name = name;\n        this.rootNode = rootNode;\n        // Hash->css\n        this.storedStyles = {};\n        // styles->hash\n        this.storedClasses = {};\n        this.style = \"\";\n        this.count = 0;\n        this.id = \"flairup-\".concat(name);\n        this.styleTag = this.createStyleTag();\n    }\n    _create_class(Sheet, [\n        {\n            key: \"getStyle\",\n            value: function getStyle() {\n                return this.style;\n            }\n        },\n        {\n            key: \"append\",\n            value: function append(css) {\n                this.style = appendString(this.style, css);\n            }\n        },\n        {\n            key: \"apply\",\n            value: function apply() {\n                this.count++;\n                if (!this.styleTag) {\n                    return;\n                }\n                this.styleTag.innerHTML = this.style;\n            }\n        },\n        {\n            key: \"isApplied\",\n            value: function isApplied() {\n                return !!this.styleTag;\n            }\n        },\n        {\n            key: \"createStyleTag\",\n            value: function createStyleTag() {\n                if (typeof document === \"undefined\" || this.isApplied() || // Explicitly disallow mounting to the DOM\n                this.rootNode === null) {\n                    return this.styleTag;\n                }\n                var styleTag = document.createElement(\"style\");\n                styleTag.type = \"text/css\";\n                styleTag.id = this.id;\n                var _this_rootNode;\n                ((_this_rootNode = this.rootNode) !== null && _this_rootNode !== void 0 ? _this_rootNode : document.head).appendChild(styleTag);\n                return styleTag;\n            }\n        },\n        {\n            key: \"addRule\",\n            value: function addRule(rule) {\n                var storedClass = this.storedClasses[rule.key];\n                if (isString(storedClass)) {\n                    return storedClass;\n                }\n                this.storedClasses[rule.key] = rule.hash;\n                this.storedStyles[rule.hash] = [\n                    rule.property,\n                    rule.value\n                ];\n                this.append(rule.toString());\n                return rule.hash;\n            }\n        }\n    ]);\n    return Sheet;\n}();\n// src/utils/forIn.ts\nfunction forIn(obj, fn) {\n    for(var key in obj){\n        fn(key.trim(), obj[key]);\n    }\n}\n// src/cx.ts\nfunction cx() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    var classes = args.reduce(function(classes2, arg) {\n        if (_instanceof(arg, Set)) {\n            var _classes2;\n            (_classes2 = classes2).push.apply(_classes2, _to_consumable_array(arg));\n        } else if (typeof arg === \"string\") {\n            classes2.push(arg);\n        } else if (Array.isArray(arg)) {\n            classes2.push(cx.apply(void 0, _to_consumable_array(arg)));\n        } else if (typeof arg === \"object\") {\n            Object.entries(arg).forEach(function(param) {\n                var _param = _sliced_to_array(param, 2), key = _param[0], value = _param[1];\n                if (value) {\n                    classes2.push(key);\n                }\n            });\n        }\n        return classes2;\n    }, []);\n    return joinTruthy(classes, \" \").trim();\n}\n// src/index.ts\nfunction createSheet(name, rootNode) {\n    var sheet = new Sheet(name, rootNode);\n    return {\n        create: create,\n        getStyle: sheet.getStyle.bind(sheet),\n        isApplied: sheet.isApplied.bind(sheet)\n    };\n    function create(styles) {\n        var scopedStyles = {};\n        iteratePreconditions(sheet, styles, new Selector(sheet)).forEach(function(param) {\n            var _param = _sliced_to_array(param, 3), scopeName = _param[0], styles2 = _param[1], selector = _param[2];\n            iterateStyles(sheet, styles2, selector).forEach(function(className) {\n                addScopedStyle(scopeName, className);\n            });\n        });\n        sheet.apply();\n        return scopedStyles;\n        function addScopedStyle(name2, className) {\n            var _scopedStyles_name2;\n            scopedStyles[name2] = (_scopedStyles_name2 = scopedStyles[name2]) !== null && _scopedStyles_name2 !== void 0 ? _scopedStyles_name2 : /* @__PURE__ */ new Set();\n            scopedStyles[name2].add(className);\n        }\n    }\n}\nfunction iteratePreconditions(sheet, styles, selector) {\n    var output = [];\n    forIn(styles, function(key, value) {\n        if (isStyleCondition(key)) {\n            return iteratePreconditions(sheet, value, selector.addPrecondition(key)).forEach(function(item) {\n                return output.push(item);\n            });\n        }\n        output.push([\n            key,\n            styles[key],\n            selector.addScope(key)\n        ]);\n    });\n    return output;\n}\nfunction iterateStyles(sheet, styles, selector) {\n    var output = /* @__PURE__ */ new Set();\n    forIn(styles, function(property, value) {\n        var res = [];\n        if (isStyleCondition(property)) {\n            res = iterateStyles(sheet, value, selector.addPostcondition(property));\n        } else if (isDirectClass(property)) {\n            res = asArray(value);\n        } else if (isMediaQuery(property)) {\n            res = handleMediaQuery(sheet, value, property, selector);\n        } else if (isCssVariables(property)) {\n            res = cssVariablesBlock(sheet, value, selector);\n        } else if (isValidProperty(property, value)) {\n            var rule = selector.createRule(property, value);\n            sheet.addRule(rule);\n            output.add(rule.hash);\n        }\n        return addEachClass(res, output);\n    });\n    return output;\n}\nfunction addEachClass(list, to) {\n    list.forEach(function(className) {\n        return to.add(className);\n    });\n    return to;\n}\nfunction cssVariablesBlock(sheet, styles, selector) {\n    var classes = /* @__PURE__ */ new Set();\n    var chunkRows = [];\n    forIn(styles, function(property, value) {\n        if (isValidProperty(property, value)) {\n            chunkRows.push(Rule.genRule(property, value));\n            return;\n        }\n        var res = iterateStyles(sheet, value !== null && value !== void 0 ? value : {}, selector);\n        addEachClass(res, classes);\n    });\n    if (!selector.scopeClassName) {\n        return classes;\n    }\n    if (chunkRows.length) {\n        var output = chunkRows.join(\" \");\n        sheet.append(\"\".concat(mergeSelectors(selector.preconditions, {\n            right: selector.scopeClassName\n        }), \" {\").concat(output, \"}\"));\n    }\n    classes.add(selector.scopeClassName);\n    return classes;\n}\nfunction handleMediaQuery(sheet, styles, mediaQuery, selector) {\n    sheet.append(mediaQuery + \" {\");\n    var output = iterateStyles(sheet, styles, selector);\n    sheet.append(\"}\");\n    return output;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZsYWlydXBAMS4wLjAvbm9kZV9tb2R1bGVzL2ZsYWlydXAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxtRkFBbUYsZ0VBQWdFO0FBQ25KLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLCtDQUErQyxzREFBc0Q7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlLQUF5SztBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FHTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVzdC1hcHAtMTQvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZsYWlydXBAMS4wLjAvbm9kZV9tb2R1bGVzL2ZsYWlydXAvZGlzdC9pbmRleC5qcz8xYTZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX2FycmF5X2xpa2VfdG9fYXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKylhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX2FycmF5X3dpdGhfaG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIF9hcnJheV93aXRob3V0X2hvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2NsYXNzX2NhbGxfY2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlX2NsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5mdW5jdGlvbiBfaW5zdGFuY2VvZihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodCAhPSBudWxsICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgcmlnaHRbU3ltYm9sLmhhc0luc3RhbmNlXSkge1xuICAgICAgICByZXR1cm4gISFyaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKGxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZWZ0IGluc3RhbmNlb2YgcmlnaHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gX2l0ZXJhYmxlX3RvX2FycmF5KGl0ZXIpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZV90b19hcnJheV9saW1pdChhcnIsIGkpIHtcbiAgICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9zLCBfZTtcbiAgICB0cnkge1xuICAgICAgICBmb3IoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpe1xuICAgICAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZCA9IHRydWU7XG4gICAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2Fycjtcbn1cbmZ1bmN0aW9uIF9ub25faXRlcmFibGVfcmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uX2l0ZXJhYmxlX3NwcmVhZCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3NsaWNlZF90b19hcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhfaG9sZXMoYXJyKSB8fCBfaXRlcmFibGVfdG9fYXJyYXlfbGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkoYXJyLCBpKSB8fCBfbm9uX2l0ZXJhYmxlX3Jlc3QoKTtcbn1cbmZ1bmN0aW9uIF90b19jb25zdW1hYmxlX2FycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlfd2l0aG91dF9ob2xlcyhhcnIpIHx8IF9pdGVyYWJsZV90b19hcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheShhcnIpIHx8IF9ub25faXRlcmFibGVfc3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShuKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9IGZ1bmN0aW9uKHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGdldDogYWxsW25hbWVdLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gZnVuY3Rpb24odG8sIGZyb20sIGV4Y2VwdCwgZGVzYykge1xuICAgIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlLCBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KSBfX2RlZlByb3AodG8sIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSlfbG9vcCgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gZnVuY3Rpb24obW9kKSB7XG4gICAgcmV0dXJuIF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICB9KSwgbW9kKTtcbn07XG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgICBjcmVhdGVTaGVldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTaGVldDtcbiAgICB9LFxuICAgIGN4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGN4O1xuICAgIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuLy8gc3JjL3V0aWxzL2FzQXJyYXkudHNcbmZ1bmN0aW9uIGFzQXJyYXkodikge1xuICAgIHJldHVybiBbXS5jb25jYXQodik7XG59XG4vLyBzcmMvdXRpbHMvaXMudHNcbmZ1bmN0aW9uIGlzUHN1ZWRvU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3Iuc3RhcnRzV2l0aChcIjpcIik7XG59XG5mdW5jdGlvbiBpc1N0eWxlQ29uZGl0aW9uKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKHNlbGVjdG9yKSAmJiAoc2VsZWN0b3IgPT09IFwiKlwiIHx8IHNlbGVjdG9yLmxlbmd0aCA+IDEgJiYgXCI6Pn4uKypcIi5pbmNsdWRlcyhzZWxlY3Rvci5zbGljZSgwLCAxKSkgfHwgaXNJbW1lZGlhdGVQb3N0Y29uZGl0aW9uKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkUHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc1N0cmluZyh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSAmJiAhaXNDc3NWYXJpYWJsZXMocHJvcGVydHkpICYmICFpc1BzdWVkb1NlbGVjdG9yKHByb3BlcnR5KSAmJiAhaXNNZWRpYVF1ZXJ5KHByb3BlcnR5KTtcbn1cbmZ1bmN0aW9uIGlzTWVkaWFRdWVyeShzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3Rvci5zdGFydHNXaXRoKFwiQG1lZGlhXCIpO1xufVxuZnVuY3Rpb24gaXNEaXJlY3RDbGFzcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciA9PT0gXCIuXCI7XG59XG5mdW5jdGlvbiBpc0Nzc1ZhcmlhYmxlcyhzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciA9PT0gXCItLVwiO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgKyBcIlwiID09PSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzSW1tZWRpYXRlUG9zdGNvbmRpdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgJiYgKHZhbHVlLnN0YXJ0c1dpdGgoXCImXCIpIHx8IGlzUHN1ZWRvU2VsZWN0b3IodmFsdWUpKTtcbn1cbi8vIHNyYy91dGlscy9qb2luVHJ1dGh5LnRzXG5mdW5jdGlvbiBqb2luVHJ1dGh5KGFycikge1xuICAgIHZhciBkZWxpbWl0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG4gICAgcmV0dXJuIGFyci5maWx0ZXIoQm9vbGVhbikuam9pbihkZWxpbWl0ZXIpO1xufVxuLy8gc3JjL3V0aWxzL3N0YWJsZUhhc2gudHNcbmZ1bmN0aW9uIHN0YWJsZUhhc2gocHJlZml4LCBzZWVkKSB7XG4gICAgdmFyIGhhc2ggPSAwO1xuICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGhhc2gudG9TdHJpbmcoKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBjaGFyID0gc2VlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hhcjtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4ICE9PSBudWxsICYmIHByZWZpeCAhPT0gdm9pZCAwID8gcHJlZml4IDogXCJjbFwiLCBcIl9cIikuY29uY2F0KGhhc2gudG9TdHJpbmcoMzYpKTtcbn1cbi8vIHNyYy91dGlscy9zdHJpbmdNYW5pcHVsYXRvcnMudHNcbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5VmFsdWUocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSBcImNvbnRlbnRcIikge1xuICAgICAgICByZXR1cm4gJ1wiJy5jb25jYXQodmFsdWUsICdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjYW1lbENhc2VUb0Rhc2goc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBqb2luZWRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQocHJvcGVydHksIFwiOlwiKS5jb25jYXQodmFsdWUpO1xufVxuZnVuY3Rpb24gdG9DbGFzcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyID8gXCIuXCIuY29uY2F0KHN0cikgOiBcIlwiO1xufVxuZnVuY3Rpb24gYXBwZW5kU3RyaW5nKGJhc2UsIGxpbmUpIHtcbiAgICByZXR1cm4gYmFzZSA/IFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXCIpLmNvbmNhdChsaW5lKSA6IGxpbmU7XG59XG4vLyBzcmMvUnVsZS50c1xudmFyIFJ1bGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIF9SdWxlKHNoZWV0LCBwcm9wZXJ0eSwgdmFsdWUsIHNlbGVjdG9yKSB7XG4gICAgICAgIF9jbGFzc19jYWxsX2NoZWNrKHRoaXMsIF9SdWxlKTtcbiAgICAgICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5qb2luZWQgPSBqb2luZWRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB2YXIgam9pbmVkQ29uZGl0aW9ucyA9IHRoaXMuc2VsZWN0b3IucHJlY29uZGl0aW9ucy5jb25jYXQodGhpcy5zZWxlY3Rvci5wb3N0Y29uZGl0aW9ucyk7XG4gICAgICAgIHRoaXMuaGFzaCA9IHRoaXMuc2VsZWN0b3IuaGFzQ29uZGl0aW9ucyA/IHRoaXMuc2VsZWN0b3Iuc2NvcGVDbGFzc05hbWUgOiBzdGFibGVIYXNoKHRoaXMuc2hlZXQubmFtZSwgdGhpcy5qb2luZWQpO1xuICAgICAgICB0aGlzLmtleSA9IGpvaW5UcnV0aHkoW1xuICAgICAgICAgICAgdGhpcy5qb2luZWQsXG4gICAgICAgICAgICBqb2luZWRDb25kaXRpb25zLFxuICAgICAgICAgICAgdGhpcy5oYXNoXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKF9SdWxlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvcnMgPSBtZXJnZVNlbGVjdG9ycyh0aGlzLnNlbGVjdG9yLnByZWNvbmRpdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuaGFzaFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IG1lcmdlU2VsZWN0b3JzKHRoaXMuc2VsZWN0b3IucG9zdGNvbmRpdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHNlbGVjdG9ycywgXCIge1wiKS5jb25jYXQoX1J1bGUuZ2VuUnVsZSh0aGlzLnByb3BlcnR5LCB0aGlzLnZhbHVlKSwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2VuUnVsZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlblJ1bGUocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUHJvcGVydHkgPSBjYW1lbENhc2VUb0Rhc2gocHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBqb2luZWRQcm9wZXJ0eSh0cmFuc2Zvcm1lZFByb3BlcnR5LCBoYW5kbGVQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LCB2YWx1ZSkpICsgXCI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gX1J1bGU7XG59KCk7XG5mdW5jdGlvbiBtZXJnZVNlbGVjdG9ycyhzZWxlY3RvcnMpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDoge30sIF9yZWZfbGVmdCA9IF9yZWYubGVmdCwgbGVmdCA9IF9yZWZfbGVmdCA9PT0gdm9pZCAwID8gXCJcIiA6IF9yZWZfbGVmdCwgX3JlZl9yaWdodCA9IF9yZWYucmlnaHQsIHJpZ2h0ID0gX3JlZl9yaWdodCA9PT0gdm9pZCAwID8gXCJcIiA6IF9yZWZfcmlnaHQ7XG4gICAgdmFyIG91dHB1dCA9IHNlbGVjdG9ycy5yZWR1Y2UoZnVuY3Rpb24oc2VsZWN0b3JzMiwgY3VycmVudCkge1xuICAgICAgICBpZiAoaXNQc3VlZG9TZWxlY3RvcihjdXJyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yczIgKyBjdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ltbWVkaWF0ZVBvc3Rjb25kaXRpb24oY3VycmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcnMyICsgY3VycmVudC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gam9pblRydXRoeShbXG4gICAgICAgICAgICBzZWxlY3RvcnMyLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICBdLCBcIiBcIik7XG4gICAgfSwgbGVmdCk7XG4gICAgcmV0dXJuIGpvaW5UcnV0aHkoW1xuICAgICAgICBvdXRwdXQsXG4gICAgICAgIHRvQ2xhc3MocmlnaHQpXG4gICAgXSwgXCIgXCIpO1xufVxudmFyIFNlbGVjdG9yID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBfU2VsZWN0b3Ioc2hlZXQpIHtcbiAgICAgICAgdmFyIHNjb3BlTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogbnVsbCwgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge30sIHByZWNvbmRpdGlvbnMgPSBfcmVmLnByZWNvbmRpdGlvbnMsIHBvc3Rjb25kaXRpb25zID0gX3JlZi5wb3N0Y29uZGl0aW9ucztcbiAgICAgICAgX2NsYXNzX2NhbGxfY2hlY2sodGhpcywgX1NlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5zaGVldCA9IHNoZWV0O1xuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5zY29wZUNsYXNzTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NvcGVOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3N0Y29uZGl0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbnMgPSBwcmVjb25kaXRpb25zID8gYXNBcnJheShwcmVjb25kaXRpb25zKSA6IFtdO1xuICAgICAgICB0aGlzLnBvc3Rjb25kaXRpb25zID0gcG9zdGNvbmRpdGlvbnMgPyBhc0FycmF5KHBvc3Rjb25kaXRpb25zKSA6IFtdO1xuICAgICAgICB0aGlzLnNldFNjb3BlKHNjb3BlTmFtZSk7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoX1NlbGVjdG9yLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJzZXRTY29wZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNjb3BlKHNjb3BlTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2NvcGVDbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY29wZU5hbWUgPSBzY29wZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGVDbGFzc05hbWUgPSBzdGFibGVIYXNoKHRoaXMuc2hlZXQubmFtZSwgLy8gYWRkaW5nIHRoZSBjb3VudCBndWFyYW50ZWVzIHVuaXF1ZW5lc3MgYWNyb3NzIHN0eWxlLmNyZWF0ZSBjYWxsc1xuICAgICAgICAgICAgICAgICAgICBzY29wZU5hbWUgKyB0aGlzLnNoZWV0LmNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJoYXNDb25kaXRpb25zXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVjb25kaXRpb25zLmxlbmd0aCA+IDAgfHwgdGhpcy5wb3N0Y29uZGl0aW9ucy5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYWRkU2NvcGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTY29wZShzY29wZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9TZWxlY3Rvcih0aGlzLnNoZWV0LCBzY29wZU5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29uZGl0aW9uczogdGhpcy5wcmVjb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBwb3N0Y29uZGl0aW9uczogdGhpcy5wb3N0Y29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYWRkUHJlY29uZGl0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUHJlY29uZGl0aW9uKHByZWNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX1NlbGVjdG9yKHRoaXMuc2hlZXQsIHRoaXMuc2NvcGVDbGFzc05hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdGNvbmRpdGlvbnM6IHRoaXMucG9zdGNvbmRpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHByZWNvbmRpdGlvbnM6IHRoaXMucHJlY29uZGl0aW9ucy5jb25jYXQocHJlY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYWRkUG9zdGNvbmRpdGlvblwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBvc3Rjb25kaXRpb24ocG9zdGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX1NlbGVjdG9yKHRoaXMuc2hlZXQsIHRoaXMuc2NvcGVDbGFzc05hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29uZGl0aW9uczogdGhpcy5wcmVjb25kaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBwb3N0Y29uZGl0aW9uczogdGhpcy5wb3N0Y29uZGl0aW9ucy5jb25jYXQocG9zdGNvbmRpdGlvbilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNyZWF0ZVJ1bGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVSdWxlKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUnVsZSh0aGlzLnNoZWV0LCBwcm9wZXJ0eSwgdmFsdWUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIF9TZWxlY3Rvcjtcbn0oKTtcbi8vIHNyYy9TaGVldC50c1xudmFyIFNoZWV0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTaGVldChuYW1lLCByb290Tm9kZSkge1xuICAgICAgICBfY2xhc3NfY2FsbF9jaGVjayh0aGlzLCBTaGVldCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcbiAgICAgICAgLy8gSGFzaC0+Y3NzXG4gICAgICAgIHRoaXMuc3RvcmVkU3R5bGVzID0ge307XG4gICAgICAgIC8vIHN0eWxlcy0+aGFzaFxuICAgICAgICB0aGlzLnN0b3JlZENsYXNzZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zdHlsZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmlkID0gXCJmbGFpcnVwLVwiLmNvbmNhdChuYW1lKTtcbiAgICAgICAgdGhpcy5zdHlsZVRhZyA9IHRoaXMuY3JlYXRlU3R5bGVUYWcoKTtcbiAgICB9XG4gICAgX2NyZWF0ZV9jbGFzcyhTaGVldCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0U3R5bGVcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHlsZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImFwcGVuZFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZChjc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlID0gYXBwZW5kU3RyaW5nKHRoaXMuc3R5bGUsIGNzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhcHBseVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlVGFnLmlubmVySFRNTCA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJpc0FwcGxpZWRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FwcGxpZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5zdHlsZVRhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNyZWF0ZVN0eWxlVGFnXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0aGlzLmlzQXBwbGllZCgpIHx8IC8vIEV4cGxpY2l0bHkgZGlzYWxsb3cgbW91bnRpbmcgdG8gdGhlIERPTVxuICAgICAgICAgICAgICAgIHRoaXMucm9vdE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVUYWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfcm9vdE5vZGU7XG4gICAgICAgICAgICAgICAgKChfdGhpc19yb290Tm9kZSA9IHRoaXMucm9vdE5vZGUpICE9PSBudWxsICYmIF90aGlzX3Jvb3ROb2RlICE9PSB2b2lkIDAgPyBfdGhpc19yb290Tm9kZSA6IGRvY3VtZW50LmhlYWQpLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJhZGRSdWxlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUnVsZShydWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlZENsYXNzID0gdGhpcy5zdG9yZWRDbGFzc2VzW3J1bGUua2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoc3RvcmVkQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZWRDbGFzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZWRDbGFzc2VzW3J1bGUua2V5XSA9IHJ1bGUuaGFzaDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlZFN0eWxlc1tydWxlLmhhc2hdID0gW1xuICAgICAgICAgICAgICAgICAgICBydWxlLnByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBydWxlLnZhbHVlXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChydWxlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlLmhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gU2hlZXQ7XG59KCk7XG4vLyBzcmMvdXRpbHMvZm9ySW4udHNcbmZ1bmN0aW9uIGZvckluKG9iaiwgZm4pIHtcbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgICBmbihrZXkudHJpbSgpLCBvYmpba2V5XSk7XG4gICAgfVxufVxuLy8gc3JjL2N4LnRzXG5mdW5jdGlvbiBjeCgpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHZhciBjbGFzc2VzID0gYXJncy5yZWR1Y2UoZnVuY3Rpb24oY2xhc3NlczIsIGFyZykge1xuICAgICAgICBpZiAoX2luc3RhbmNlb2YoYXJnLCBTZXQpKSB7XG4gICAgICAgICAgICB2YXIgX2NsYXNzZXMyO1xuICAgICAgICAgICAgKF9jbGFzc2VzMiA9IGNsYXNzZXMyKS5wdXNoLmFwcGx5KF9jbGFzc2VzMiwgX3RvX2NvbnN1bWFibGVfYXJyYXkoYXJnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY2xhc3NlczIucHVzaChhcmcpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgY2xhc3NlczIucHVzaChjeC5hcHBseSh2b2lkIDAsIF90b19jb25zdW1hYmxlX2FycmF5KGFyZykpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhhcmcpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgX3BhcmFtID0gX3NsaWNlZF90b19hcnJheShwYXJhbSwgMiksIGtleSA9IF9wYXJhbVswXSwgdmFsdWUgPSBfcGFyYW1bMV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMyLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NlczI7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBqb2luVHJ1dGh5KGNsYXNzZXMsIFwiIFwiKS50cmltKCk7XG59XG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGNyZWF0ZVNoZWV0KG5hbWUsIHJvb3ROb2RlKSB7XG4gICAgdmFyIHNoZWV0ID0gbmV3IFNoZWV0KG5hbWUsIHJvb3ROb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICAgICAgZ2V0U3R5bGU6IHNoZWV0LmdldFN0eWxlLmJpbmQoc2hlZXQpLFxuICAgICAgICBpc0FwcGxpZWQ6IHNoZWV0LmlzQXBwbGllZC5iaW5kKHNoZWV0KVxuICAgIH07XG4gICAgZnVuY3Rpb24gY3JlYXRlKHN0eWxlcykge1xuICAgICAgICB2YXIgc2NvcGVkU3R5bGVzID0ge307XG4gICAgICAgIGl0ZXJhdGVQcmVjb25kaXRpb25zKHNoZWV0LCBzdHlsZXMsIG5ldyBTZWxlY3RvcihzaGVldCkpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciBfcGFyYW0gPSBfc2xpY2VkX3RvX2FycmF5KHBhcmFtLCAzKSwgc2NvcGVOYW1lID0gX3BhcmFtWzBdLCBzdHlsZXMyID0gX3BhcmFtWzFdLCBzZWxlY3RvciA9IF9wYXJhbVsyXTtcbiAgICAgICAgICAgIGl0ZXJhdGVTdHlsZXMoc2hlZXQsIHN0eWxlczIsIHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGFkZFNjb3BlZFN0eWxlKHNjb3BlTmFtZSwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc2hlZXQuYXBwbHkoKTtcbiAgICAgICAgcmV0dXJuIHNjb3BlZFN0eWxlcztcbiAgICAgICAgZnVuY3Rpb24gYWRkU2NvcGVkU3R5bGUobmFtZTIsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdmFyIF9zY29wZWRTdHlsZXNfbmFtZTI7XG4gICAgICAgICAgICBzY29wZWRTdHlsZXNbbmFtZTJdID0gKF9zY29wZWRTdHlsZXNfbmFtZTIgPSBzY29wZWRTdHlsZXNbbmFtZTJdKSAhPT0gbnVsbCAmJiBfc2NvcGVkU3R5bGVzX25hbWUyICE9PSB2b2lkIDAgPyBfc2NvcGVkU3R5bGVzX25hbWUyIDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHNjb3BlZFN0eWxlc1tuYW1lMl0uYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyYXRlUHJlY29uZGl0aW9ucyhzaGVldCwgc3R5bGVzLCBzZWxlY3Rvcikge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3JJbihzdHlsZXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzU3R5bGVDb25kaXRpb24oa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVQcmVjb25kaXRpb25zKHNoZWV0LCB2YWx1ZSwgc2VsZWN0b3IuYWRkUHJlY29uZGl0aW9uKGtleSkpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHN0eWxlc1trZXldLFxuICAgICAgICAgICAgc2VsZWN0b3IuYWRkU2NvcGUoa2V5KVxuICAgICAgICBdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gaXRlcmF0ZVN0eWxlcyhzaGVldCwgc3R5bGVzLCBzZWxlY3Rvcikge1xuICAgIHZhciBvdXRwdXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvckluKHN0eWxlcywgZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgaWYgKGlzU3R5bGVDb25kaXRpb24ocHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXMgPSBpdGVyYXRlU3R5bGVzKHNoZWV0LCB2YWx1ZSwgc2VsZWN0b3IuYWRkUG9zdGNvbmRpdGlvbihwcm9wZXJ0eSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGlyZWN0Q2xhc3MocHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXMgPSBhc0FycmF5KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01lZGlhUXVlcnkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXMgPSBoYW5kbGVNZWRpYVF1ZXJ5KHNoZWV0LCB2YWx1ZSwgcHJvcGVydHksIHNlbGVjdG9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nzc1ZhcmlhYmxlcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJlcyA9IGNzc1ZhcmlhYmxlc0Jsb2NrKHNoZWV0LCB2YWx1ZSwgc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmFsaWRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgcnVsZSA9IHNlbGVjdG9yLmNyZWF0ZVJ1bGUocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICAgIHNoZWV0LmFkZFJ1bGUocnVsZSk7XG4gICAgICAgICAgICBvdXRwdXQuYWRkKHJ1bGUuaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZEVhY2hDbGFzcyhyZXMsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGFkZEVhY2hDbGFzcyhsaXN0LCB0bykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRvLmFkZChjbGFzc05hbWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0bztcbn1cbmZ1bmN0aW9uIGNzc1ZhcmlhYmxlc0Jsb2NrKHNoZWV0LCBzdHlsZXMsIHNlbGVjdG9yKSB7XG4gICAgdmFyIGNsYXNzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHZhciBjaHVua1Jvd3MgPSBbXTtcbiAgICBmb3JJbihzdHlsZXMsIGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNWYWxpZFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNodW5rUm93cy5wdXNoKFJ1bGUuZ2VuUnVsZShwcm9wZXJ0eSwgdmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gaXRlcmF0ZVN0eWxlcyhzaGVldCwgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDoge30sIHNlbGVjdG9yKTtcbiAgICAgICAgYWRkRWFjaENsYXNzKHJlcywgY2xhc3Nlcyk7XG4gICAgfSk7XG4gICAgaWYgKCFzZWxlY3Rvci5zY29wZUNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG4gICAgaWYgKGNodW5rUm93cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGNodW5rUm93cy5qb2luKFwiIFwiKTtcbiAgICAgICAgc2hlZXQuYXBwZW5kKFwiXCIuY29uY2F0KG1lcmdlU2VsZWN0b3JzKHNlbGVjdG9yLnByZWNvbmRpdGlvbnMsIHtcbiAgICAgICAgICAgIHJpZ2h0OiBzZWxlY3Rvci5zY29wZUNsYXNzTmFtZVxuICAgICAgICB9KSwgXCIge1wiKS5jb25jYXQob3V0cHV0LCBcIn1cIikpO1xuICAgIH1cbiAgICBjbGFzc2VzLmFkZChzZWxlY3Rvci5zY29wZUNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIGNsYXNzZXM7XG59XG5mdW5jdGlvbiBoYW5kbGVNZWRpYVF1ZXJ5KHNoZWV0LCBzdHlsZXMsIG1lZGlhUXVlcnksIHNlbGVjdG9yKSB7XG4gICAgc2hlZXQuYXBwZW5kKG1lZGlhUXVlcnkgKyBcIiB7XCIpO1xuICAgIHZhciBvdXRwdXQgPSBpdGVyYXRlU3R5bGVzKHNoZWV0LCBzdHlsZXMsIHNlbGVjdG9yKTtcbiAgICBzaGVldC5hcHBlbmQoXCJ9XCIpO1xuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVTaGVldDogY3JlYXRlU2hlZXQsXG4gICAgY3g6IGN4XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/../../node_modules/.pnpm/flairup@1.0.0/node_modules/flairup/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/flairup@1.0.0/node_modules/flairup/dist/esm/index.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/flairup@1.0.0/node_modules/flairup/dist/esm/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSheet: () => (/* binding */ createSheet),\n/* harmony export */   cx: () => (/* binding */ cx)\n/* harmony export */ });\n// src/utils/asArray.ts\nfunction asArray(v) {\n  return [].concat(v);\n}\n\n// src/utils/is.ts\nfunction isPsuedoSelector(selector) {\n  return selector.startsWith(\":\");\n}\nfunction isStyleCondition(selector) {\n  return isString(selector) && (selector === \"*\" || selector.length > 1 && \":>~.+*\".includes(selector.slice(0, 1)) || isImmediatePostcondition(selector));\n}\nfunction isValidProperty(property, value) {\n  return (isString(value) || typeof value === \"number\") && !isCssVariables(property) && !isPsuedoSelector(property) && !isMediaQuery(property);\n}\nfunction isMediaQuery(selector) {\n  return selector.startsWith(\"@media\");\n}\nfunction isDirectClass(selector) {\n  return selector === \".\";\n}\nfunction isCssVariables(selector) {\n  return selector === \"--\";\n}\nfunction isString(value) {\n  return value + \"\" === value;\n}\nfunction isImmediatePostcondition(value) {\n  return isString(value) && (value.startsWith(\"&\") || isPsuedoSelector(value));\n}\n\n// src/utils/joinTruthy.ts\nfunction joinTruthy(arr, delimiter = \"\") {\n  return arr.filter(Boolean).join(delimiter);\n}\n\n// src/utils/stableHash.ts\nfunction stableHash(prefix, seed) {\n  let hash = 0;\n  if (seed.length === 0)\n    return hash.toString();\n  for (let i = 0; i < seed.length; i++) {\n    const char = seed.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash;\n  }\n  return `${prefix ?? \"cl\"}_${hash.toString(36)}`;\n}\n\n// src/utils/stringManipulators.ts\nfunction handlePropertyValue(property, value) {\n  if (property === \"content\") {\n    return `\"${value}\"`;\n  }\n  return value;\n}\nfunction camelCaseToDash(str) {\n  return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction joinedProperty(property, value) {\n  return `${property}:${value}`;\n}\nfunction toClass(str) {\n  return str ? `.${str}` : \"\";\n}\nfunction appendString(base, line) {\n  return base ? `${base}\n${line}` : line;\n}\n\n// src/Rule.ts\nvar Rule = class _Rule {\n  constructor(sheet, property, value, selector) {\n    this.sheet = sheet;\n    this.property = property;\n    this.value = value;\n    this.selector = selector;\n    this.property = property;\n    this.value = value;\n    this.joined = joinedProperty(property, value);\n    const joinedConditions = this.selector.preconditions.concat(\n      this.selector.postconditions\n    );\n    this.hash = this.selector.hasConditions ? this.selector.scopeClassName : stableHash(this.sheet.name, this.joined);\n    this.key = joinTruthy([this.joined, joinedConditions, this.hash]);\n  }\n  toString() {\n    let selectors = mergeSelectors(this.selector.preconditions, {\n      right: this.hash\n    });\n    selectors = mergeSelectors(this.selector.postconditions, {\n      left: selectors\n    });\n    return `${selectors} {${_Rule.genRule(this.property, this.value)}}`;\n  }\n  static genRule(property, value) {\n    const transformedProperty = camelCaseToDash(property);\n    return joinedProperty(\n      transformedProperty,\n      handlePropertyValue(property, value)\n    ) + \";\";\n  }\n};\nfunction mergeSelectors(selectors, { left = \"\", right = \"\" } = {}) {\n  const output = selectors.reduce((selectors2, current) => {\n    if (isPsuedoSelector(current)) {\n      return selectors2 + current;\n    }\n    if (isImmediatePostcondition(current)) {\n      return selectors2 + current.slice(1);\n    }\n    return joinTruthy([selectors2, current], \" \");\n  }, left);\n  return joinTruthy([output, toClass(right)], \" \");\n}\nvar Selector = class _Selector {\n  constructor(sheet, scopeName = null, {\n    preconditions,\n    postconditions\n  } = {}) {\n    this.sheet = sheet;\n    this.preconditions = [];\n    this.scopeClassName = null;\n    this.scopeName = null;\n    this.postconditions = [];\n    this.preconditions = preconditions ? asArray(preconditions) : [];\n    this.postconditions = postconditions ? asArray(postconditions) : [];\n    this.setScope(scopeName);\n  }\n  setScope(scopeName) {\n    if (!scopeName) {\n      return this;\n    }\n    if (!this.scopeClassName) {\n      this.scopeName = scopeName;\n      this.scopeClassName = stableHash(\n        this.sheet.name,\n        // adding the count guarantees uniqueness across style.create calls\n        scopeName + this.sheet.count\n      );\n    }\n    return this;\n  }\n  get hasConditions() {\n    return this.preconditions.length > 0 || this.postconditions.length > 0;\n  }\n  addScope(scopeName) {\n    return new _Selector(this.sheet, scopeName, {\n      preconditions: this.preconditions,\n      postconditions: this.postconditions\n    });\n  }\n  addPrecondition(precondition) {\n    return new _Selector(this.sheet, this.scopeClassName, {\n      postconditions: this.postconditions,\n      preconditions: this.preconditions.concat(precondition)\n    });\n  }\n  addPostcondition(postcondition) {\n    return new _Selector(this.sheet, this.scopeClassName, {\n      preconditions: this.preconditions,\n      postconditions: this.postconditions.concat(postcondition)\n    });\n  }\n  createRule(property, value) {\n    return new Rule(this.sheet, property, value, this);\n  }\n};\n\n// src/Sheet.ts\nvar Sheet = class {\n  constructor(name, rootNode) {\n    this.name = name;\n    this.rootNode = rootNode;\n    // Hash->css\n    this.storedStyles = {};\n    // styles->hash\n    this.storedClasses = {};\n    this.style = \"\";\n    this.count = 0;\n    this.id = `flairup-${name}`;\n    this.styleTag = this.createStyleTag();\n  }\n  getStyle() {\n    return this.style;\n  }\n  append(css) {\n    this.style = appendString(this.style, css);\n  }\n  apply() {\n    this.count++;\n    if (!this.styleTag) {\n      return;\n    }\n    this.styleTag.innerHTML = this.style;\n  }\n  isApplied() {\n    return !!this.styleTag;\n  }\n  createStyleTag() {\n    if (typeof document === \"undefined\" || this.isApplied() || // Explicitly disallow mounting to the DOM\n    this.rootNode === null) {\n      return this.styleTag;\n    }\n    const styleTag = document.createElement(\"style\");\n    styleTag.type = \"text/css\";\n    styleTag.id = this.id;\n    (this.rootNode ?? document.head).appendChild(styleTag);\n    return styleTag;\n  }\n  addRule(rule) {\n    const storedClass = this.storedClasses[rule.key];\n    if (isString(storedClass)) {\n      return storedClass;\n    }\n    this.storedClasses[rule.key] = rule.hash;\n    this.storedStyles[rule.hash] = [rule.property, rule.value];\n    this.append(rule.toString());\n    return rule.hash;\n  }\n};\n\n// src/utils/forIn.ts\nfunction forIn(obj, fn) {\n  for (const key in obj) {\n    fn(key.trim(), obj[key]);\n  }\n}\n\n// src/cx.ts\nfunction cx(...args) {\n  const classes = args.reduce((classes2, arg) => {\n    if (arg instanceof Set) {\n      classes2.push(...arg);\n    } else if (typeof arg === \"string\") {\n      classes2.push(arg);\n    } else if (Array.isArray(arg)) {\n      classes2.push(cx(...arg));\n    } else if (typeof arg === \"object\") {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (value) {\n          classes2.push(key);\n        }\n      });\n    }\n    return classes2;\n  }, []);\n  return joinTruthy(classes, \" \").trim();\n}\n\n// src/index.ts\nfunction createSheet(name, rootNode) {\n  const sheet = new Sheet(name, rootNode);\n  return {\n    create,\n    getStyle: sheet.getStyle.bind(sheet),\n    isApplied: sheet.isApplied.bind(sheet)\n  };\n  function create(styles) {\n    const scopedStyles = {};\n    iteratePreconditions(sheet, styles, new Selector(sheet)).forEach(\n      ([scopeName, styles2, selector]) => {\n        iterateStyles(sheet, styles2, selector).forEach(\n          (className) => {\n            addScopedStyle(scopeName, className);\n          }\n        );\n      }\n    );\n    sheet.apply();\n    return scopedStyles;\n    function addScopedStyle(name2, className) {\n      scopedStyles[name2] = scopedStyles[name2] ?? /* @__PURE__ */ new Set();\n      scopedStyles[name2].add(className);\n    }\n  }\n}\nfunction iteratePreconditions(sheet, styles, selector) {\n  const output = [];\n  forIn(styles, (key, value) => {\n    if (isStyleCondition(key)) {\n      return iteratePreconditions(\n        sheet,\n        value,\n        selector.addPrecondition(key)\n      ).forEach((item) => output.push(item));\n    }\n    output.push([key, styles[key], selector.addScope(key)]);\n  });\n  return output;\n}\nfunction iterateStyles(sheet, styles, selector) {\n  const output = /* @__PURE__ */ new Set();\n  forIn(styles, (property, value) => {\n    let res = [];\n    if (isStyleCondition(property)) {\n      res = iterateStyles(\n        sheet,\n        value,\n        selector.addPostcondition(property)\n      );\n    } else if (isDirectClass(property)) {\n      res = asArray(value);\n    } else if (isMediaQuery(property)) {\n      res = handleMediaQuery(sheet, value, property, selector);\n    } else if (isCssVariables(property)) {\n      res = cssVariablesBlock(sheet, value, selector);\n    } else if (isValidProperty(property, value)) {\n      const rule = selector.createRule(property, value);\n      sheet.addRule(rule);\n      output.add(rule.hash);\n    }\n    return addEachClass(res, output);\n  });\n  return output;\n}\nfunction addEachClass(list, to) {\n  list.forEach((className) => to.add(className));\n  return to;\n}\nfunction cssVariablesBlock(sheet, styles, selector) {\n  const classes = /* @__PURE__ */ new Set();\n  const chunkRows = [];\n  forIn(styles, (property, value) => {\n    if (isValidProperty(property, value)) {\n      chunkRows.push(Rule.genRule(property, value));\n      return;\n    }\n    const res = iterateStyles(sheet, value ?? {}, selector);\n    addEachClass(res, classes);\n  });\n  if (!selector.scopeClassName) {\n    return classes;\n  }\n  if (chunkRows.length) {\n    const output = chunkRows.join(\" \");\n    sheet.append(\n      `${mergeSelectors(selector.preconditions, {\n        right: selector.scopeClassName\n      })} {${output}}`\n    );\n  }\n  classes.add(selector.scopeClassName);\n  return classes;\n}\nfunction handleMediaQuery(sheet, styles, mediaQuery, selector) {\n  sheet.append(mediaQuery + \" {\");\n  const output = iterateStyles(sheet, styles, selector);\n  sheet.append(\"}\");\n  return output;\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZsYWlydXBAMS4wLjAvbm9kZV9tb2R1bGVzL2ZsYWlydXAvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZSxHQUFHLGtCQUFrQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVMsR0FBRyxNQUFNO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEVBQUUsS0FBSztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxZQUFZLEVBQUUsMENBQTBDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EscUNBQXFDLHdCQUF3QixJQUFJO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU8sSUFBSSxFQUFFLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVzdC1hcHAtMTQvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZsYWlydXBAMS4wLjAvbm9kZV9tb2R1bGVzL2ZsYWlydXAvZGlzdC9lc20vaW5kZXguanM/NDUxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMvYXNBcnJheS50c1xuZnVuY3Rpb24gYXNBcnJheSh2KSB7XG4gIHJldHVybiBbXS5jb25jYXQodik7XG59XG5cbi8vIHNyYy91dGlscy9pcy50c1xuZnVuY3Rpb24gaXNQc3VlZG9TZWxlY3RvcihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3Iuc3RhcnRzV2l0aChcIjpcIik7XG59XG5mdW5jdGlvbiBpc1N0eWxlQ29uZGl0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBpc1N0cmluZyhzZWxlY3RvcikgJiYgKHNlbGVjdG9yID09PSBcIipcIiB8fCBzZWxlY3Rvci5sZW5ndGggPiAxICYmIFwiOj5+LisqXCIuaW5jbHVkZXMoc2VsZWN0b3Iuc2xpY2UoMCwgMSkpIHx8IGlzSW1tZWRpYXRlUG9zdGNvbmRpdGlvbihzZWxlY3RvcikpO1xufVxuZnVuY3Rpb24gaXNWYWxpZFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gKGlzU3RyaW5nKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpICYmICFpc0Nzc1ZhcmlhYmxlcyhwcm9wZXJ0eSkgJiYgIWlzUHN1ZWRvU2VsZWN0b3IocHJvcGVydHkpICYmICFpc01lZGlhUXVlcnkocHJvcGVydHkpO1xufVxuZnVuY3Rpb24gaXNNZWRpYVF1ZXJ5KHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3Rvci5zdGFydHNXaXRoKFwiQG1lZGlhXCIpO1xufVxuZnVuY3Rpb24gaXNEaXJlY3RDbGFzcyhzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT09IFwiLlwiO1xufVxuZnVuY3Rpb24gaXNDc3NWYXJpYWJsZXMoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09PSBcIi0tXCI7XG59XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgKyBcIlwiID09PSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzSW1tZWRpYXRlUG9zdGNvbmRpdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNTdHJpbmcodmFsdWUpICYmICh2YWx1ZS5zdGFydHNXaXRoKFwiJlwiKSB8fCBpc1BzdWVkb1NlbGVjdG9yKHZhbHVlKSk7XG59XG5cbi8vIHNyYy91dGlscy9qb2luVHJ1dGh5LnRzXG5mdW5jdGlvbiBqb2luVHJ1dGh5KGFyciwgZGVsaW1pdGVyID0gXCJcIikge1xuICByZXR1cm4gYXJyLmZpbHRlcihCb29sZWFuKS5qb2luKGRlbGltaXRlcik7XG59XG5cbi8vIHNyYy91dGlscy9zdGFibGVIYXNoLnRzXG5mdW5jdGlvbiBzdGFibGVIYXNoKHByZWZpeCwgc2VlZCkge1xuICBsZXQgaGFzaCA9IDA7XG4gIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gaGFzaC50b1N0cmluZygpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc2VlZC5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaGFyO1xuICAgIGhhc2ggPSBoYXNoICYgaGFzaDtcbiAgfVxuICByZXR1cm4gYCR7cHJlZml4ID8/IFwiY2xcIn1fJHtoYXNoLnRvU3RyaW5nKDM2KX1gO1xufVxuXG4vLyBzcmMvdXRpbHMvc3RyaW5nTWFuaXB1bGF0b3JzLnRzXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LCB2YWx1ZSkge1xuICBpZiAocHJvcGVydHkgPT09IFwiY29udGVudFwiKSB7XG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNhbWVsQ2FzZVRvRGFzaChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBqb2luZWRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIGAke3Byb3BlcnR5fToke3ZhbHVlfWA7XG59XG5mdW5jdGlvbiB0b0NsYXNzKHN0cikge1xuICByZXR1cm4gc3RyID8gYC4ke3N0cn1gIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGFwcGVuZFN0cmluZyhiYXNlLCBsaW5lKSB7XG4gIHJldHVybiBiYXNlID8gYCR7YmFzZX1cbiR7bGluZX1gIDogbGluZTtcbn1cblxuLy8gc3JjL1J1bGUudHNcbnZhciBSdWxlID0gY2xhc3MgX1J1bGUge1xuICBjb25zdHJ1Y3RvcihzaGVldCwgcHJvcGVydHksIHZhbHVlLCBzZWxlY3Rvcikge1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuam9pbmVkID0gam9pbmVkUHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICBjb25zdCBqb2luZWRDb25kaXRpb25zID0gdGhpcy5zZWxlY3Rvci5wcmVjb25kaXRpb25zLmNvbmNhdChcbiAgICAgIHRoaXMuc2VsZWN0b3IucG9zdGNvbmRpdGlvbnNcbiAgICApO1xuICAgIHRoaXMuaGFzaCA9IHRoaXMuc2VsZWN0b3IuaGFzQ29uZGl0aW9ucyA/IHRoaXMuc2VsZWN0b3Iuc2NvcGVDbGFzc05hbWUgOiBzdGFibGVIYXNoKHRoaXMuc2hlZXQubmFtZSwgdGhpcy5qb2luZWQpO1xuICAgIHRoaXMua2V5ID0gam9pblRydXRoeShbdGhpcy5qb2luZWQsIGpvaW5lZENvbmRpdGlvbnMsIHRoaXMuaGFzaF0pO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBzZWxlY3RvcnMgPSBtZXJnZVNlbGVjdG9ycyh0aGlzLnNlbGVjdG9yLnByZWNvbmRpdGlvbnMsIHtcbiAgICAgIHJpZ2h0OiB0aGlzLmhhc2hcbiAgICB9KTtcbiAgICBzZWxlY3RvcnMgPSBtZXJnZVNlbGVjdG9ycyh0aGlzLnNlbGVjdG9yLnBvc3Rjb25kaXRpb25zLCB7XG4gICAgICBsZWZ0OiBzZWxlY3RvcnNcbiAgICB9KTtcbiAgICByZXR1cm4gYCR7c2VsZWN0b3JzfSB7JHtfUnVsZS5nZW5SdWxlKHRoaXMucHJvcGVydHksIHRoaXMudmFsdWUpfX1gO1xuICB9XG4gIHN0YXRpYyBnZW5SdWxlKHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkUHJvcGVydHkgPSBjYW1lbENhc2VUb0Rhc2gocHJvcGVydHkpO1xuICAgIHJldHVybiBqb2luZWRQcm9wZXJ0eShcbiAgICAgIHRyYW5zZm9ybWVkUHJvcGVydHksXG4gICAgICBoYW5kbGVQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LCB2YWx1ZSlcbiAgICApICsgXCI7XCI7XG4gIH1cbn07XG5mdW5jdGlvbiBtZXJnZVNlbGVjdG9ycyhzZWxlY3RvcnMsIHsgbGVmdCA9IFwiXCIsIHJpZ2h0ID0gXCJcIiB9ID0ge30pIHtcbiAgY29uc3Qgb3V0cHV0ID0gc2VsZWN0b3JzLnJlZHVjZSgoc2VsZWN0b3JzMiwgY3VycmVudCkgPT4ge1xuICAgIGlmIChpc1BzdWVkb1NlbGVjdG9yKGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JzMiArIGN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChpc0ltbWVkaWF0ZVBvc3Rjb25kaXRpb24oY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcnMyICsgY3VycmVudC5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIGpvaW5UcnV0aHkoW3NlbGVjdG9yczIsIGN1cnJlbnRdLCBcIiBcIik7XG4gIH0sIGxlZnQpO1xuICByZXR1cm4gam9pblRydXRoeShbb3V0cHV0LCB0b0NsYXNzKHJpZ2h0KV0sIFwiIFwiKTtcbn1cbnZhciBTZWxlY3RvciA9IGNsYXNzIF9TZWxlY3RvciB7XG4gIGNvbnN0cnVjdG9yKHNoZWV0LCBzY29wZU5hbWUgPSBudWxsLCB7XG4gICAgcHJlY29uZGl0aW9ucyxcbiAgICBwb3N0Y29uZGl0aW9uc1xuICB9ID0ge30pIHtcbiAgICB0aGlzLnNoZWV0ID0gc2hlZXQ7XG4gICAgdGhpcy5wcmVjb25kaXRpb25zID0gW107XG4gICAgdGhpcy5zY29wZUNsYXNzTmFtZSA9IG51bGw7XG4gICAgdGhpcy5zY29wZU5hbWUgPSBudWxsO1xuICAgIHRoaXMucG9zdGNvbmRpdGlvbnMgPSBbXTtcbiAgICB0aGlzLnByZWNvbmRpdGlvbnMgPSBwcmVjb25kaXRpb25zID8gYXNBcnJheShwcmVjb25kaXRpb25zKSA6IFtdO1xuICAgIHRoaXMucG9zdGNvbmRpdGlvbnMgPSBwb3N0Y29uZGl0aW9ucyA/IGFzQXJyYXkocG9zdGNvbmRpdGlvbnMpIDogW107XG4gICAgdGhpcy5zZXRTY29wZShzY29wZU5hbWUpO1xuICB9XG4gIHNldFNjb3BlKHNjb3BlTmFtZSkge1xuICAgIGlmICghc2NvcGVOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNjb3BlQ2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgICAgIHRoaXMuc2NvcGVDbGFzc05hbWUgPSBzdGFibGVIYXNoKFxuICAgICAgICB0aGlzLnNoZWV0Lm5hbWUsXG4gICAgICAgIC8vIGFkZGluZyB0aGUgY291bnQgZ3VhcmFudGVlcyB1bmlxdWVuZXNzIGFjcm9zcyBzdHlsZS5jcmVhdGUgY2FsbHNcbiAgICAgICAgc2NvcGVOYW1lICsgdGhpcy5zaGVldC5jb3VudFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IGhhc0NvbmRpdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJlY29uZGl0aW9ucy5sZW5ndGggPiAwIHx8IHRoaXMucG9zdGNvbmRpdGlvbnMubGVuZ3RoID4gMDtcbiAgfVxuICBhZGRTY29wZShzY29wZU5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9TZWxlY3Rvcih0aGlzLnNoZWV0LCBzY29wZU5hbWUsIHtcbiAgICAgIHByZWNvbmRpdGlvbnM6IHRoaXMucHJlY29uZGl0aW9ucyxcbiAgICAgIHBvc3Rjb25kaXRpb25zOiB0aGlzLnBvc3Rjb25kaXRpb25zXG4gICAgfSk7XG4gIH1cbiAgYWRkUHJlY29uZGl0aW9uKHByZWNvbmRpdGlvbikge1xuICAgIHJldHVybiBuZXcgX1NlbGVjdG9yKHRoaXMuc2hlZXQsIHRoaXMuc2NvcGVDbGFzc05hbWUsIHtcbiAgICAgIHBvc3Rjb25kaXRpb25zOiB0aGlzLnBvc3Rjb25kaXRpb25zLFxuICAgICAgcHJlY29uZGl0aW9uczogdGhpcy5wcmVjb25kaXRpb25zLmNvbmNhdChwcmVjb25kaXRpb24pXG4gICAgfSk7XG4gIH1cbiAgYWRkUG9zdGNvbmRpdGlvbihwb3N0Y29uZGl0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBfU2VsZWN0b3IodGhpcy5zaGVldCwgdGhpcy5zY29wZUNsYXNzTmFtZSwge1xuICAgICAgcHJlY29uZGl0aW9uczogdGhpcy5wcmVjb25kaXRpb25zLFxuICAgICAgcG9zdGNvbmRpdGlvbnM6IHRoaXMucG9zdGNvbmRpdGlvbnMuY29uY2F0KHBvc3Rjb25kaXRpb24pXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlUnVsZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFJ1bGUodGhpcy5zaGVldCwgcHJvcGVydHksIHZhbHVlLCB0aGlzKTtcbiAgfVxufTtcblxuLy8gc3JjL1NoZWV0LnRzXG52YXIgU2hlZXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIHJvb3ROb2RlKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG4gICAgLy8gSGFzaC0+Y3NzXG4gICAgdGhpcy5zdG9yZWRTdHlsZXMgPSB7fTtcbiAgICAvLyBzdHlsZXMtPmhhc2hcbiAgICB0aGlzLnN0b3JlZENsYXNzZXMgPSB7fTtcbiAgICB0aGlzLnN0eWxlID0gXCJcIjtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLmlkID0gYGZsYWlydXAtJHtuYW1lfWA7XG4gICAgdGhpcy5zdHlsZVRhZyA9IHRoaXMuY3JlYXRlU3R5bGVUYWcoKTtcbiAgfVxuICBnZXRTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZTtcbiAgfVxuICBhcHBlbmQoY3NzKSB7XG4gICAgdGhpcy5zdHlsZSA9IGFwcGVuZFN0cmluZyh0aGlzLnN0eWxlLCBjc3MpO1xuICB9XG4gIGFwcGx5KCkge1xuICAgIHRoaXMuY291bnQrKztcbiAgICBpZiAoIXRoaXMuc3R5bGVUYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdHlsZVRhZy5pbm5lckhUTUwgPSB0aGlzLnN0eWxlO1xuICB9XG4gIGlzQXBwbGllZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN0eWxlVGFnO1xuICB9XG4gIGNyZWF0ZVN0eWxlVGFnKCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgdGhpcy5pc0FwcGxpZWQoKSB8fCAvLyBFeHBsaWNpdGx5IGRpc2FsbG93IG1vdW50aW5nIHRvIHRoZSBET01cbiAgICB0aGlzLnJvb3ROb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZVRhZztcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgc3R5bGVUYWcudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgICBzdHlsZVRhZy5pZCA9IHRoaXMuaWQ7XG4gICAgKHRoaXMucm9vdE5vZGUgPz8gZG9jdW1lbnQuaGVhZCkuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuICAgIHJldHVybiBzdHlsZVRhZztcbiAgfVxuICBhZGRSdWxlKHJ1bGUpIHtcbiAgICBjb25zdCBzdG9yZWRDbGFzcyA9IHRoaXMuc3RvcmVkQ2xhc3Nlc1tydWxlLmtleV07XG4gICAgaWYgKGlzU3RyaW5nKHN0b3JlZENsYXNzKSkge1xuICAgICAgcmV0dXJuIHN0b3JlZENsYXNzO1xuICAgIH1cbiAgICB0aGlzLnN0b3JlZENsYXNzZXNbcnVsZS5rZXldID0gcnVsZS5oYXNoO1xuICAgIHRoaXMuc3RvcmVkU3R5bGVzW3J1bGUuaGFzaF0gPSBbcnVsZS5wcm9wZXJ0eSwgcnVsZS52YWx1ZV07XG4gICAgdGhpcy5hcHBlbmQocnVsZS50b1N0cmluZygpKTtcbiAgICByZXR1cm4gcnVsZS5oYXNoO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvZm9ySW4udHNcbmZ1bmN0aW9uIGZvckluKG9iaiwgZm4pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgZm4oa2V5LnRyaW0oKSwgb2JqW2tleV0pO1xuICB9XG59XG5cbi8vIHNyYy9jeC50c1xuZnVuY3Rpb24gY3goLi4uYXJncykge1xuICBjb25zdCBjbGFzc2VzID0gYXJncy5yZWR1Y2UoKGNsYXNzZXMyLCBhcmcpID0+IHtcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBjbGFzc2VzMi5wdXNoKC4uLmFyZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjbGFzc2VzMi5wdXNoKGFyZyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGNsYXNzZXMyLnB1c2goY3goLi4uYXJnKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhhcmcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBjbGFzc2VzMi5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NlczI7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGpvaW5UcnV0aHkoY2xhc3NlcywgXCIgXCIpLnRyaW0oKTtcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBjcmVhdGVTaGVldChuYW1lLCByb290Tm9kZSkge1xuICBjb25zdCBzaGVldCA9IG5ldyBTaGVldChuYW1lLCByb290Tm9kZSk7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlLFxuICAgIGdldFN0eWxlOiBzaGVldC5nZXRTdHlsZS5iaW5kKHNoZWV0KSxcbiAgICBpc0FwcGxpZWQ6IHNoZWV0LmlzQXBwbGllZC5iaW5kKHNoZWV0KVxuICB9O1xuICBmdW5jdGlvbiBjcmVhdGUoc3R5bGVzKSB7XG4gICAgY29uc3Qgc2NvcGVkU3R5bGVzID0ge307XG4gICAgaXRlcmF0ZVByZWNvbmRpdGlvbnMoc2hlZXQsIHN0eWxlcywgbmV3IFNlbGVjdG9yKHNoZWV0KSkuZm9yRWFjaChcbiAgICAgIChbc2NvcGVOYW1lLCBzdHlsZXMyLCBzZWxlY3Rvcl0pID0+IHtcbiAgICAgICAgaXRlcmF0ZVN0eWxlcyhzaGVldCwgc3R5bGVzMiwgc2VsZWN0b3IpLmZvckVhY2goXG4gICAgICAgICAgKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgICAgYWRkU2NvcGVkU3R5bGUoc2NvcGVOYW1lLCBjbGFzc05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHNoZWV0LmFwcGx5KCk7XG4gICAgcmV0dXJuIHNjb3BlZFN0eWxlcztcbiAgICBmdW5jdGlvbiBhZGRTY29wZWRTdHlsZShuYW1lMiwgY2xhc3NOYW1lKSB7XG4gICAgICBzY29wZWRTdHlsZXNbbmFtZTJdID0gc2NvcGVkU3R5bGVzW25hbWUyXSA/PyAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgc2NvcGVkU3R5bGVzW25hbWUyXS5hZGQoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGl0ZXJhdGVQcmVjb25kaXRpb25zKHNoZWV0LCBzdHlsZXMsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBmb3JJbihzdHlsZXMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKGlzU3R5bGVDb25kaXRpb24oa2V5KSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGVQcmVjb25kaXRpb25zKFxuICAgICAgICBzaGVldCxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHNlbGVjdG9yLmFkZFByZWNvbmRpdGlvbihrZXkpXG4gICAgICApLmZvckVhY2goKGl0ZW0pID0+IG91dHB1dC5wdXNoKGl0ZW0pKTtcbiAgICB9XG4gICAgb3V0cHV0LnB1c2goW2tleSwgc3R5bGVzW2tleV0sIHNlbGVjdG9yLmFkZFNjb3BlKGtleSldKTtcbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBpdGVyYXRlU3R5bGVzKHNoZWV0LCBzdHlsZXMsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IG91dHB1dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvckluKHN0eWxlcywgKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBpZiAoaXNTdHlsZUNvbmRpdGlvbihwcm9wZXJ0eSkpIHtcbiAgICAgIHJlcyA9IGl0ZXJhdGVTdHlsZXMoXG4gICAgICAgIHNoZWV0LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgc2VsZWN0b3IuYWRkUG9zdGNvbmRpdGlvbihwcm9wZXJ0eSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0RpcmVjdENsYXNzKHByb3BlcnR5KSkge1xuICAgICAgcmVzID0gYXNBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc01lZGlhUXVlcnkocHJvcGVydHkpKSB7XG4gICAgICByZXMgPSBoYW5kbGVNZWRpYVF1ZXJ5KHNoZWV0LCB2YWx1ZSwgcHJvcGVydHksIHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3NzVmFyaWFibGVzKHByb3BlcnR5KSkge1xuICAgICAgcmVzID0gY3NzVmFyaWFibGVzQmxvY2soc2hlZXQsIHZhbHVlLCBzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkUHJvcGVydHkocHJvcGVydHksIHZhbHVlKSkge1xuICAgICAgY29uc3QgcnVsZSA9IHNlbGVjdG9yLmNyZWF0ZVJ1bGUocHJvcGVydHksIHZhbHVlKTtcbiAgICAgIHNoZWV0LmFkZFJ1bGUocnVsZSk7XG4gICAgICBvdXRwdXQuYWRkKHJ1bGUuaGFzaCk7XG4gICAgfVxuICAgIHJldHVybiBhZGRFYWNoQ2xhc3MocmVzLCBvdXRwdXQpO1xuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGFkZEVhY2hDbGFzcyhsaXN0LCB0bykge1xuICBsaXN0LmZvckVhY2goKGNsYXNzTmFtZSkgPT4gdG8uYWRkKGNsYXNzTmFtZSkpO1xuICByZXR1cm4gdG87XG59XG5mdW5jdGlvbiBjc3NWYXJpYWJsZXNCbG9jayhzaGVldCwgc3R5bGVzLCBzZWxlY3Rvcikge1xuICBjb25zdCBjbGFzc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgY2h1bmtSb3dzID0gW107XG4gIGZvckluKHN0eWxlcywgKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgIGlmIChpc1ZhbGlkUHJvcGVydHkocHJvcGVydHksIHZhbHVlKSkge1xuICAgICAgY2h1bmtSb3dzLnB1c2goUnVsZS5nZW5SdWxlKHByb3BlcnR5LCB2YWx1ZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBpdGVyYXRlU3R5bGVzKHNoZWV0LCB2YWx1ZSA/PyB7fSwgc2VsZWN0b3IpO1xuICAgIGFkZEVhY2hDbGFzcyhyZXMsIGNsYXNzZXMpO1xuICB9KTtcbiAgaWYgKCFzZWxlY3Rvci5zY29wZUNsYXNzTmFtZSkge1xuICAgIHJldHVybiBjbGFzc2VzO1xuICB9XG4gIGlmIChjaHVua1Jvd3MubGVuZ3RoKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gY2h1bmtSb3dzLmpvaW4oXCIgXCIpO1xuICAgIHNoZWV0LmFwcGVuZChcbiAgICAgIGAke21lcmdlU2VsZWN0b3JzKHNlbGVjdG9yLnByZWNvbmRpdGlvbnMsIHtcbiAgICAgICAgcmlnaHQ6IHNlbGVjdG9yLnNjb3BlQ2xhc3NOYW1lXG4gICAgICB9KX0geyR7b3V0cHV0fX1gXG4gICAgKTtcbiAgfVxuICBjbGFzc2VzLmFkZChzZWxlY3Rvci5zY29wZUNsYXNzTmFtZSk7XG4gIHJldHVybiBjbGFzc2VzO1xufVxuZnVuY3Rpb24gaGFuZGxlTWVkaWFRdWVyeShzaGVldCwgc3R5bGVzLCBtZWRpYVF1ZXJ5LCBzZWxlY3Rvcikge1xuICBzaGVldC5hcHBlbmQobWVkaWFRdWVyeSArIFwiIHtcIik7XG4gIGNvbnN0IG91dHB1dCA9IGl0ZXJhdGVTdHlsZXMoc2hlZXQsIHN0eWxlcywgc2VsZWN0b3IpO1xuICBzaGVldC5hcHBlbmQoXCJ9XCIpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlU2hlZXQsXG4gIGN4XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/flairup@1.0.0/node_modules/flairup/dist/esm/index.js\n");

/***/ })

};
;